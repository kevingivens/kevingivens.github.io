{"componentChunkName":"component---src-templates-post-tsx","path":"/cython-bindings-in-py-ql","result":{"data":{"post":{"slug":"/cython-bindings-in-py-ql","title":"Cython Bindings in PyQL","date":"10.03.2020","tags":[{"name":"Cython","slug":"cython"}],"description":null,"canonicalUrl":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Cython Bindings in PyQL\",\n  \"date\": \"2020-03-10T00:00:00.000Z\",\n  \"tags\": [\"Cython\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Summary: We review the general approach to Cython bindings in the PyQL library.\"), mdx(\"p\", null, \"Recently, I've written a few posts, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/kevingivens/blog/local-volatility-in-pyql.html\"\n  }, \"here\"), \" and\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/kevingivens/blog/variance-swaps-in-pyql.html\"\n  }, \"here\"), \",\\nabout my contributions to the PyQL library.  I thought I would take the opportunity\\nto review the general approach I've been using.  Although Cython is a fantastic tool\\nfor writing Python bindings, its support for some of C++'s more advanced features (e.g. templates, smart pointers) is not\\nwell documented online.  Hopefully these notes may be of use to Cython binding writers in general.\"), mdx(\"h2\", null, \"The Basic Idea\"), mdx(\"p\", null, \"The basic approach to writing bindings is to build wrapper functions around each\\nfunction in the compiled language use wish to export to users.  These wrapper functions manage\\nthe input and output of data to the compiled functions, such that the user of the wrapper function can\\nsafely ignore the details of the compiled language.  A schematic of this is given below\", mdx(\"sup\", {\n    parentName: \"p\",\n    \"id\": \"fnref-1\"\n  }, mdx(\"a\", {\n    parentName: \"sup\",\n    \"href\": \"#fn-1\",\n    \"className\": \"footnote-ref\"\n  }, \"1\"))), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"%7B./image_wrapper.jpg\",\n    \"alt\": \"png\"\n  }), \"  \"), mdx(\"p\", null, \"This approach applies to classes as well.  Let's take a look at a non-trivial example from PyQL to better understand the approach.\"), mdx(\"p\", null, \"Consider the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CreditDefaultSwap\"), \" class from Quantlib(ql/instruments/creditdefaultswap.hpp). Its class definition looks like the following\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c++\"\n  }, \"class CreditDefaultSwap : public Instrument {\\n\\n  CreditDefaultSwap(Protection::Side side,\\n                    Real notional,\\n                    Rate spread,\\n                    ...\\n                    const DayCounter& lastPeriodDayCounter = DayCounter(),\\n                    const bool rebatesAccrual = true);\\n  ...\\n  Protection::Side side() const;\\n  Real notional() const;\\n  ...\\n\")), mdx(\"p\", null, \"Where I've ignored most of the constructor arguments and class methods to simplify the discussion.\"), mdx(\"p\", null, \"To expose this class in PyQL we first declare it in a cython definition file (.pxd) as follows\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cython\"\n  }, \"cdef extern from 'ql/instruments/creditdefaultswap.hpp' namespace 'QuantLib':\\n\\n    cdef cppclass CreditDefaultSwap(Instrument):\\n        CreditDefaultSwap(Side side,\\n                          Real notional,\\n                          Rate spread,\\n                          ...                      \\n                          DayCounter& last_period_day_counter,\\n                          bool rebates_accrual\\n        )\\n        int side()\\n        Real notional()\\n        ...\\n\")), mdx(\"p\", null, \"For each of these declared classes we build a corresponding wrapper class in python. These python classes are defined in cython implementation file (.pyx) and are importable as python modules.\"), mdx(\"p\", null, \"For the credit default swap, the python wrapper class is given below\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cython\"\n  }, \"cdef class CreditDefaultSwap(Instrument):\\n\\n    def __init__(self,\\n                 Side side,\\n                 double notional,\\n                 double spread,\\n                 ...\\n                 DayCounter last_period_day_counter = Actual360(True),\\n                 bool rebates_accrual=True):\\n        \\\"\\\"\\\"Credit default swap as running-spread only\\n        \\\"\\\"\\\"\\n\\n        self._thisptr = shared_ptr[_instrument.Instrument](\\n            new _cds.CreditDefaultSwap(\\n                side, notional, spread, deref(schedule._thisptr),\\n                payment_convention,\\n                deref(day_counter._thisptr), settles_accrual, pays_at_default_time,\\n                deref(protection_start._thisptr),\\n                shared_ptr[_cds.Claim](),\\n                deref(last_period_day_counter._thisptr),\\n                rebates_accrual)\\n        )\\n\\n\")), mdx(\"p\", null, \"From this example we make the following observations:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The constructor exposes Python objects to the user.  Simple types like double and bool\\nare automatically converted by the cython compiler to the corresponding python type.\\nMore complex types such as DayCounter are defined elsewhere in the PyQL and imported to this file.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The wrapper class manages the C++ class by means of a internal smart pointer\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"self._thisptr = shared_ptr[_instrument.Instrument](new _cds.CreditDefaultSwap ...\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"This pointer controls the lifetime of the corresponding C++ object along with\\nany methods that are applied to it.  When the python object goes out of scope it\\nresets the smart pointer which frees the memory that was allocated to the C++ object.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Internal smart pointers are also used to pass C++ objects into the C++ constructor.  For instance\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"deref(schedule._thisptr)\\n\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Inheritance is managed by casting the smart pointer from Instrument down to CreditDefaultSwap.\\nMost classes in PyQL have utility functions to perform this cast.  For the CDS, it's given below\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cython\"\n  }, \"cdef inline _cds.CreditDefaultSwap* _get_cds(CreditDefaultSwap cds):\\n    return <_cds.CreditDefaultSwap*>cds._thisptr.get()\\n\")), mdx(\"p\", null, \"This allows us to access the CDS's methods like the following snippet\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cython\"\n  }, \"@property\\n    def notional(self):\\n        return _get_cds(self).notional()\\n\\n\")), mdx(\"h2\", null, \"Import Dilemma\"), mdx(\"p\", null, \"The astute reader (you're all astute, I'm sure) will have noticed that both the C++ object and the Python object have the same name \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CreditDefaultSwap\"), \".  \"), mdx(\"p\", null, \"This causes a name collision and a dilemma.  What's the best way to avoid such a collision? Some libraries take the approach of renaming the C/C++ object Foo_C or the Python object Foo_Py. PyQL takes a different approach.  \"), mdx(\"p\", null, \"They first place the C++ objects in an underscored pxd file. For instance `_credit_default_swap.pxd'. They then import these objects into the pyx files as follows\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cython\"\n  }, \"import _credit_default_swap as _cds\\n\\n\")), mdx(\"p\", null, \"The reason for the the underscore is that definition files with the same name as a pyx file, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"credit_default_swap.pxd\"), \", are automatically imported into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"credit_default_swap.pyx\")), mdx(\"p\", null, \"This leads to the situation where there are three files for every one hpp file. This isn't ideal, but at least it's consistent and avoids having to rename C++ objects.\"), mdx(\"h1\", null, \"Python Data Structures\"), mdx(\"p\", null, \"One of the main reasons to prefer Cython over other binding tools is its flexibility.\\nPyQL takes advantage of this flexibility to make Quantlib more compatible with standard\\nPython data structures.  For example, Quantlib provides custom Date and Matrix objects\\nthat are used throughout the library.  Python users would naturally prefer to use\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"datetime.Date\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NumPy\"), \" arrays instead of the custom objects.  PyQL provides utilities\\nfor converting between these standard Python objects.\"), mdx(\"p\", null, \"Numpy arrays are converted via \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"quantlib.math.matrix.pyx\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cython\"\n  }, \"def to_ndarray(self):\\n    cdef np.npy_intp[2] dims\\n    dims[0] = self._thisptr.rows()\\n    dims[1] = self._thisptr.columns()\\n    cdef arr = np.PyArray_SimpleNew(2, &dims[0], np.NPY_DOUBLE)\\n    cdef double[:,::1] r = arr\\n    cdef size_t i, j\\n    for i in range(dims[0]):\\n        for j in range(dims[1]):\\n            r[i,j] = self._thisptr[i][j]\\n    return arr\\n\")), mdx(\"p\", null, \"Similarly, datetime.date's are converted via \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"quantlib.time.date.pyx\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cython\"\n  }, \"def object _pydate_from_qldate(QlDate qdate):\\n    \\\"\\\"\\\" Converts a QuantLib Date (C++) to a datetime.date object. \\\"\\\"\\\"\\n\\n    cdef int m = qdate.month()\\n    cdef int d = qdate.dayOfMonth()\\n    cdef int y = qdate.year()\\n\\n    return date_new(y, m, d)\\n\")), mdx(\"div\", {\n    \"className\": \"footnotes\"\n  }, mdx(\"hr\", {\n    parentName: \"div\"\n  }), mdx(\"ol\", {\n    parentName: \"div\"\n  }, mdx(\"li\", {\n    parentName: \"ol\",\n    \"id\": \"fn-1\"\n  }, \"Credit: David Beazley Swig Master \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://www.dabeaz.com/SwigMaster/SWIGMaster.pdf\"\n  }, \"Class\"), \".\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#fnref-1\",\n    \"className\": \"footnote-backref\"\n  }, \"\\u21A9\")))));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Summary: We review the general approach to Cython bindings in the PyQL library. Recently, I've written a few posts,  here  and\n here ,\naboutâ€¦","timeToRead":2,"banner":null}},"pageContext":{"slug":"/cython-bindings-in-py-ql","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["2744905544","3090400250","318001574"]}