{"componentChunkName":"component---src-templates-post-tsx","path":"/automating-the-binding-process-in-cython-part-2","result":{"data":{"post":{"slug":"/automating-the-binding-process-in-cython-part-2","title":"Automating the Binding Process in Cython, Part 2","date":"27.04.2020","tags":[{"name":"Python","slug":"python"},{"name":"Cython","slug":"cython"}],"description":null,"canonicalUrl":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Automating the Binding Process in Cython, Part 2\",\n  \"date\": \"2020-04-27T00:00:00.000Z\",\n  \"tags\": [\"Python\", \"Cython\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Summary: We continue to discuss an approach towards automating the writing of Cython\\nbindings. We focus on generating pyx files.\"), mdx(\"h3\", null, \"Part 2, Overview\"), mdx(\"p\", null, \"Welcome back. In the previous \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"%7Battach%7Dpost8.md\"\n  }, \"post\"), \", I discussed generating pxd files (Cython C-level declarations)\\nfrom C header files using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/eliben/pycparser\"\n  }, \"pycparser\"), \".  In this post, I want to explore using Cython's\\nown parser to generate the corresponding Python wrapper classes and functions in a\\npyx files.  As always, you can find the companion code to this post on my \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/kevingivens/Blog\"\n  }, \"github page\"), \".\"), mdx(\"h2\", null, \"Using Cython's Parser\"), mdx(\"p\", null, \"As a reminder from the last post, we are generating Python bindings for a C\\nimplementation of a trie data structure from the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/fragglet/c-algorithms\"\n  }, \"c-algorithms library\"), \"\\n(Incidentally, code from this same library is used as an example in the official Cython\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://cython.readthedocs.io/en/latest/src/tutorial/clibraries.html\"\n  }, \"documentation\"), \".\\nThere's a lot of overlap between that documentation of some of the topics discussed here).\"), mdx(\"p\", null, \"Cython's parser in written in Python.  It's fairly straight-forward to use, though\\nnot terribly well documented.  As with any conventional parser, each Cython declaration is\\nrepresented as a node in an abstract syntax tree.  The parser reads\\nCython code in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pyx\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pxd\"), \", or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pxi\"), \" files and generates C code that implements\\nthe CPython API.   \"), mdx(\"p\", null, \"Our approach, borrowed from the autowrap \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/uweschmitt/autowrap\"\n  }, \"project\"), \",\\nis to use Cython's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pxd\"), \" reading capabilities to generate \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pyx\"), \" files. After all,\\nfor most Cython projects, one tries to maintain some type of consistent standard\\nwhen implementing wrapper functions and classes.  Using a parser just implements\\nthese standards automatically.\"), mdx(\"h3\", null, \"Compiler Pipeline\"), mdx(\"p\", null, \"Now for some code.  Cython's pxd parser can be accessed programatically.  In the snippet below,\\nwe parse a pxd file from the command line and return an AST.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from Cython.Compiler.CmdLine import parse_command_line\\nfrom Cython.Compiler.Main import create_default_resultobj, CompilationSource\\nfrom Cython.Compiler import Pipeline\\nfrom Cython.Compiler.Scanning import FileSourceDescriptor\\n\\n\\ndef parse_pxd_file(path):\\n    options, sources = parse_command_line([\\\"\\\", path])\\n\\n    path = os.path.abspath(path)\\n    basename = os.path.basename(path)\\n    name, ext = os.path.splitext(basename)\\n\\n    source_desc = FileSourceDescriptor(path, basename)\\n    source = CompilationSource(source_desc, name, os.getcwd())\\n    result = create_default_resultobj(source, options)\\n\\n    context = options.create_context()\\n    pipeline = Pipeline.create_pyx_pipeline(context, options, result)\\n    context.setup_errors(options, result)\\n    # root of the AST/parse tree\\n    root = pipeline[0](source)\\n\")), mdx(\"p\", null, \"We use the function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parse_command_line\"), \" to pass the source code located at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"path\"), \" to\\nthe Cython compiler with no compiler flags turned on. We then create a pxy compiler\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Pipeline\"), \" from a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CompilationSource\"), \" objects and a default \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"options context\"), \".\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"This pipeline is like a regular compiler pipeline through which phases of data\\ntransformation and optimizations occur.  For our purposes, we will just walk the AST starting\\nfrom the root node.\"), mdx(\"p\", null, \"Parsing our trie.pxd file from the previous post generates the following AST, which is schematically shown below\\n(we leave off most leaves for presentation purposes):\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"960px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"35.416666666666664%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAm0lEQVQY053NsQ6DMAxFUf7/LyEiQGxiRzg4VDipRNWhA5XaM73BV+7avZzzMAwxxruD7ktcawUAEfknZuZxHAHgPM+f49YaIu77/ttnMzuOY11X730IoZRiZrVWM/uIzUzfykVE5nlGRBGZpomZU0rLshBRjPFxUVUz67ZtQ0TnHAAwMxG5S845pdT3PQCoagjBOUdEzOy9f+0nVkWX9WZlbjkAAAAASUVORK5CYII=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"png\",\n    \"title\": \"png\",\n    \"src\": \"/static/8ef8c8a2487b22e9392caa272f86bc74/7d769/trie_ast.png\",\n    \"srcSet\": [\"/static/8ef8c8a2487b22e9392caa272f86bc74/5243c/trie_ast.png 240w\", \"/static/8ef8c8a2487b22e9392caa272f86bc74/ab158/trie_ast.png 480w\", \"/static/8ef8c8a2487b22e9392caa272f86bc74/7d769/trie_ast.png 960w\", \"/static/8ef8c8a2487b22e9392caa272f86bc74/78687/trie_ast.png 1212w\"],\n    \"sizes\": \"(max-width: 960px) 100vw, 960px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  }), \"\\n    \")), mdx(\"h2\", null, \"Pxd Visitor\"), mdx(\"p\", null, \"We implement a Pxd Visitor object following the protocol defined in Cython.  In particular,\\nour PxdVisitor implements a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"visit\"), \" method for every type of node in the AST.  For instance\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def visit_CStructOrUnionDefNode(self, node):\\n    # extract info from node\\n    return self.visitchildren(node)\\n\")), mdx(\"p\", null, \"visits the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CStructOrUnionDef\"), \" type node in the AST representing a union or struct declarations.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def visit_CTypeDefNode(self, node):\\n    # extract info from node\\n    return self.visitchildren(node)\\n\")), mdx(\"p\", null, \"visits \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ctypedefs\"), \" and so on.\"), mdx(\"p\", null, \"Our Visitor class walks all the nodes in the tree and collects information that we need to build the\\ncorresponding Python wrapper classes and functions.  For a given struct (in our example\\nthe \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Trie\"), \" struct), the visitor collects all the C functions that will become Python class methods.\\nThese are identified by the fact that their names match the name of the struct.  For example, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"trie_new\"), \" and\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"trie_insert\"), \" are functions for creating \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Trie\"), \" structs and inserting data into them respectively.\"), mdx(\"p\", null, \"Once all the C functions are mapped to their corresponding structs, the Python classes can be built using string templates along\\nwith functions for managing type conversions between Python and C.  We will explore this approach below.\"), mdx(\"h2\", null, \"Python Class Lifetime Management\"), mdx(\"p\", null, \"The C structs defined in the pxd files should be wrapped by Python classes, as these are\\nthe closest language equivalent.  Ideally, the Python classes will manage the\\nlifetime of the corresponding C struct.  This means that the C struct will be\\ncreated when the Python class is created and it will be destroyed and its memory\\nreleased when the Python class is destroyed.  In this way, the C struct is\\n\\\"buried under the hood\\\", so the speak, and the user of the Python class is essentially\\noblivious to its existence.\"), mdx(\"p\", null, \"For our trie example, the Python wrapper class looks like the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cython\"\n  }, \"cimport _trie\\n\\ncdef class Trie:\\n\\n    cdef _trie.Trie* _this_ptr\\n\\n    def __cinit__(self):\\n        self._this_ptr = _trie.trie_new()\\n        if self._this_ptr is NULL:\\n            raise MemoryError()\\n\\n    def __dealloc__(self):\\n        if self._this_ptr is not NULL:\\n            _trie.trie_free(self._this_ptr)\\n\")), mdx(\"p\", null, \"This ensures that the lifetime of the underlying C Trie struct is tied to the lifetime\\nof the Python Trie class.\"), mdx(\"h2\", null, \"Wrapping Functions\"), mdx(\"p\", null, \"Wrapping C functions is simple in principle.  The idea is to cast the Python\\nobjects from the function signature into their nearest C equivalent type,\\nthen call the underlying C function via the classes' internal pointer and finally convert any\\nreturned C objects back to Python types.  Wrapping functions is essentially an exercise in\\nmanaging type conversions between C and Python.\"), mdx(\"p\", null, \"However, in practice, this can be a difficult task for a compiler to achieve. For\\ninstance, in our Trie example the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"insert\"), \" method has the following C signature\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"int trie_insert(Trie *trie, char *key, TrieValue value);\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Trie *trie\"), \" can be replaced with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"self.this_ptr\"), \". The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"char* key\"), \" argument\\ncan be replaced with a Python string (more on this below). TrieValue is a typedef of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"void*\"), \",\\nwhich is C approach to generic programming. From the Python side, we have a\\nfew choices in terms preserving this generacy.\"), mdx(\"p\", null, \"One approach would be to declare \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \" to be a generic Python type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"object\"), \" and then attempt to cast it to a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<void*>\"), \"\\nin the C function call, i.e.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cython\"\n  }, \"def insert(self, ..., object value);\\n    return<int> _trie.trie_insert(self.this_ptr, ..., <void*>value)\\n\")), mdx(\"p\", null, \"However this could easily fail if the user passed in a nonsensical value object.\"), mdx(\"p\", null, \"The other approach, as advocated by the Cython \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://cython.readthedocs.io/en/latest/src/tutorial/clibraries.html\"\n  }, \"documentation\"), \",\\nis to specify a concrete type in the Python function call, for instance, int or double.\\nThis breaks type generacy but prevents runtime errors.  \"), mdx(\"p\", null, \"Interestingly, this is also the approach used by autowrap to handle C++ templates.  In autowrap,\\nthe user can specify the concrete Python type they wish to implement using a compiler directive.  This eases the burdon of\\nhaving to implement highly redundant Python classes for every concrete Python type one wishes to use.\\nI may implement a compiler directive like this at some point in the future.\"), mdx(\"p\", null, \"As for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"char *\"), \" in the C function, exposing a Python \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"str\"), \" (unicode in Python 3) is\\nthoroughly in the Cython documentation.  We just implement the type conversion directly.  \"), mdx(\"p\", null, \"So a naive Python wrapper would look like the following\", mdx(\"sup\", {\n    parentName: \"p\",\n    \"id\": \"fnref-1\"\n  }, mdx(\"a\", {\n    parentName: \"sup\",\n    \"href\": \"#fn-1\",\n    \"className\": \"footnote-ref\"\n  }, \"1\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cython\"\n  }, \"def insert(self, str key, int value):\\n    py_byte_str = key.encode('UTF-8')\\n    cdef char* c_key = py_byte_str\\n    return self._this_ptr.trie_insert(Trie *trie, c_key, <void *>value)\\n\\n\")), mdx(\"p\", null, \"There is one more problem with this approach, namely that the returned \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int\"), \" is\\nnot really meant to be an integer, per se.  It's an int from a C function call\\nindicating failure by a 0 and success by a positive value.  This is one of C's (limited)\\napproach to runtime error handling. Clearly, a parser just looking at the pxd\\nreturn type cannot distinguish between an int of this type and a regular int.\"), mdx(\"p\", null, \"Cython provides an alternative type, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bint\"), \", as in binary int, that can be used\\nfor these types of function calls.  A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bint\"), \" auto-converts to a Python \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bool\"), \"\\ninstead of an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int\"), \".  So for our pxd parser to pick it up, we would have to\\nmanually update our pxd file from\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"int trie_insert(Trie *trie, char *key, TrieValue value);\\n\")), mdx(\"p\", null, \"to\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"bint trie_insert(Trie *trie, char *key, TrieValue value);\\n\")), mdx(\"p\", null, \"The returned \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bint\"), \"'s value should be checked and an exception should be raised if it\\nis false.  So am improved wrapper look like the following\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cython\"\n  }, \"def insert(self, str key, int value):\\n    py_byte_str = key.encode('UTF-8')\\n    cdef char* c_key = py_byte_str\\n    if not _trie.trie_insert(self._thisptr, c_key, <void *>value):\\n        raise MemoryError()\\n\")), mdx(\"h2\", null, \"Python Protocols and Special Methods\"), mdx(\"p\", null, \"As an easier wrapping example, the length of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"trie\"), \" struct can be determined via the\\nfollowing function\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"unsigned int trie_num_entries(Trie *trie);\\n\")), mdx(\"p\", null, \"Our python wrapper is simply\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cython\"\n  }, \"def num_enties(self):\\n    return _trie.trie_num_entries(self._this_ptr)\\n\")), mdx(\"p\", null, \"Clearly, Python users would expect a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__len__()\"), \" special method instead of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"num_entries()\"), \".\\nWe can either allow users to adjust the function name manually after generating the pyx file\\nor directly map \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"num_enties\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__len__\"), \" in the pxd parser. We'll use a direct mapping\\nfor now but it's by no means a general solution.  \"), mdx(\"p\", null, \"So our length method would look like the following\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cython\"\n  }, \"def __len__(self):\\n    return _trie.trie_num_entries(self._this_ptr)\\n\")), mdx(\"p\", null, \"This problem can emerge for any C functions that implements Python protocol functionality,\\nsuch as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__get__()\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__set__()\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \" __getitem__(key)\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__setitem__(key, value)\"), \", etc.\"), mdx(\"h2\", null, \"Handling Includes\"), mdx(\"p\", null, \"Includes should be one of the simple aspects of the parser.  However, there is\\none subtlety that needs to be addressed.  In particular, Cython has a convention\\nwhereby for any pyx file, say \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo.pyx\"), \", all C declarations from a pxd file with\\nthe same name, e.g. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo.pxd\"), \", are automatically included at compile time.  This can\\ncause a name collision if we wish to give our Python classes and functions the same\\nname in Python as they have in the underlying C library.\"), mdx(\"p\", null, \"One approach to avoiding name collisions is to first name the pxd file \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_foo.pxd\"), \"\\n(add a leading underscore) to prevent it from being automatically included in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo.pyx\"), \".\\nThen rename the imported C declarations with a leading underscore in the pyx file.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"This will prevent C and Python names from colliding in the pyx file.\"), mdx(\"h2\", null, \"Putting it All Together\"), mdx(\"p\", null, \"So, running our pyx generator and manually replacing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"void*\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bint\"), \"\\nwe get the following Python wrapper class\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cython\"\n  }, \"cimport trie\\n\\ncdef class Trie:\\n\\n    cdef trie.Trie* _this_ptr\\n\\n    def __cinit__(self, ):\\n        self._this_ptr = trie.trie_new()\\n        if self._this_ptr is NULL:\\n            raise MemoryError()\\n\\n    def __dealloc__(self):\\n        if self._this_ptr is not NULL:\\n            trie.trie_free(self._this_ptr)\\n\\n    cdef insert(self, str key, int value):\\n        py_byte_str = key.encode('UTF-8')\\n        cdef char* c_key = py_byte_str\\n        if not trie.trie_insert(self._thisptr, c_key, <void*>value):\\n            raise MemoryError()\\n\\n\\n    cdef insert_binary(self, str key, int key_length, int value):\\n        py_byte_str = key.encode('UTF-8')\\n        cdef char* c_key = py_byte_str\\n        if not trie.trie_insert(self._thisptr, c_key, <void*>value):\\n            raise MemoryError()\\n\\n\\n    cdef lookup(self, str key):\\n        py_byte_str = key.encode('UTF-8')\\n        cdef char* c_key = py_byte_str\\n        return <int>trie.trie_lookup(self._this_ptr, c_key)\\n\\n\\n    cdef lookup_binary(self, str key, int key_length):\\n        py_byte_str = key.encode('UTF-8')\\n        cdef char* c_key = py_byte_str\\n        return <int>trie.trie_lookup_binary(self._this_ptr, c_key, <int>key_length)\\n\\n\\n    cdef remove(self, str key):\\n        py_byte_str = key.encode('UTF-8')\\n        cdef char* c_key = py_byte_str\\n        return <int>trie.trie_remove(self._this_ptr, c_key)\\n\\n\\n    cdef remove_binary(self, str key, int key_length):\\n        py_byte_str = key.encode('UTF-8')\\n        cdef char* c_key = py_byte_str\\n        return <int>trie.trie_remove_binary(self._this_ptr, c_key, <int>key_length)\\n\\n\\n    cdef __len__(self):\\n        return <int>trie.trie_num_entries(self._this_ptr)\\n\")), mdx(\"h2\", null, \"Final Words\"), mdx(\"p\", null, \"There's much more work to do on the pxy generator.  For instance, the following items still need to be\\nhandled\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Enums\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Compiler directives\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Comments\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"More special function mapping\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Exception Handling\")), mdx(\"p\", null, \"In my next post, I will revisit this process for C++.  In particular, I'll use\\nlibClang to parse C++ header files along with autowrap for Pyx generation.  See you next time.\"), mdx(\"div\", {\n    \"className\": \"footnotes\"\n  }, mdx(\"hr\", {\n    parentName: \"div\"\n  }), mdx(\"ol\", {\n    parentName: \"div\"\n  }, mdx(\"li\", {\n    parentName: \"ol\",\n    \"id\": \"fn-1\"\n  }, \"See Cython's \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://cython.readthedocs.io/en/latest/src/tutorial/strings.html\"\n  }, \"documentation\"), \" on the need for the temporary \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"py_byte_str\"), \" object\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#fnref-1\",\n    \"className\": \"footnote-backref\"\n  }, \"\\u21A9\")))));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Summary: We continue to discuss an approach towards automating the writing of Cython\nbindings. We focus on generating pyx files. Part…","timeToRead":5,"banner":null}},"pageContext":{"slug":"/automating-the-binding-process-in-cython-part-2","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["2744905544","3090400250","318001574"]}