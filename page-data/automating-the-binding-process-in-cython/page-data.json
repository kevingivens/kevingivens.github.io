{"componentChunkName":"component---src-templates-post-tsx","path":"/automating-the-binding-process-in-cython","result":{"data":{"post":{"slug":"/automating-the-binding-process-in-cython","title":"Automating the Binding Process in Cython","date":"20.04.2020","tags":[{"name":"Python","slug":"python"},{"name":"Cython","slug":"cython"}],"description":null,"canonicalUrl":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Automating the Binding Process in Cython\",\n  \"date\": \"2020-04-20T00:00:00.000Z\",\n  \"tags\": [\"Python\", \"Cython\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Summary: We discuss an approach towards automating the writing of Cython bindings\"), mdx(\"h3\", null, \"Part 1, Overview\"), mdx(\"p\", null, \"Cython is a wonderful tool for writing Python bindings.  It gives the developer a\\ntremendous amount of control over both code performance and semantics in a language\\nthat is a superset of Python. It's no surprise much of the Scientific Python\\necosystem uses Cython to wrap C and C++ libraries.\"), mdx(\"p\", null, \"However, in this post, I want to discuss one of the common pain points of Cython as\\nwell an approach I'm currently working on to alleviate some of this pain.\\nThe pain point I'm focusing on is the shear amount of code one needs to write in\\nCython. Consider the following dummy C++ class\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"// foo.hpp\\n\\nclass Foo {\\n    Foo(int a);\\n    int foo_meth(int b);\\n}\\n\")), mdx(\"p\", null, \"In order to build cython bindings for this class, one would need write, at a minimum,\\none pxd file for the c-level declaration\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"# foo.pxd\\n\\ncdef cppclass Foo:\\n    Foo(int a)\\n    int foo_meth(int b)\\n\\n\")), mdx(\"p\", null, \"and one pyx file for the python class that wraps the C++ classes\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cython\"\n  }, \"# foo.pyx\\n\\ncdef class Foo:\\n\\n    cdef shared_ptr[_foo.Foo] _thisptr\\n\\n    def __cinit__(self, a):\\n        self._thisptr = _foo.Foo(<int>a)\\n\\n    def __dealloc__(self):\\n        if self._thisptr == NULL:\\n            self._thisptr.reset()\\n\\n    def foo_meth(b):\\n        return self._thisptr.foo_meth(<int>a)\\n\\n\")), mdx(\"p\", null, \"So you can see that 3 lines from a C++ file becomes ~12 lines of Cython.  This\\nisn't a major problem for small C or C++ libraries, but for large libraries with\\n1000's of interface files, writing Cython bindings for the entire library becomes\\na colossal task.\"), mdx(\"p\", null, \"A second problem can arise when a C or C++ library is under heavy active development.\\nPublic interfaces may change significantly from one release to the next rendering your\\nhard-fought Cython bindings obsolete.  Like Sisyphus, you're plagued with the\\neternal task of keeping your bindings up to date with the latest release.\"), mdx(\"p\", null, \"One natural approach to resolving this dilemma to write a computer program\\nthat automatically generates these bindings for you, \\\"on the fly\\\", every time there is a\\nnew release of the underlying C or C++ library.  It's this approach I want to\\ndiscuss in here.\"), mdx(\"p\", null, \"The essence of the idea is familiar for anyone who has studied compilers. If you\\nwant to transform data (in this case, code) from one language (C/C+) to another (Cython)\\nyou need a parser.  The work flow is to first translate the C/C++ source code into an\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Abstract_syntax_tree\"\n  }, \"abstract syntax tree\"), \" and\\nthen to walk the tree and generate the transformed Cython code. So all we need in\\norder to give this approach a try is a C/C++ parser.  Know any good ones?\"), mdx(\"p\", null, \"Just kidding, sort of.  Until recently, the only C/C++ parser in the open source\\nworld was buried inside GCC along with linkers, Fortran parsers, and various other\\ngoodies. Thankfully, this situation has improved with the LLVM project.  Clang is\\nproduction quality C family compiler whose parser is accessible in python through\\nthe \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://clang.llvm.org/doxygen/group__CINDEX.html\"\n  }, \"libClang\"), \" bindings. The\\nstory for C code, is even better.  There is an open source C parser written in pure\\npython called \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/eliben/pycparser\"\n  }, \"pycparser\"), \".\"), mdx(\"p\", null, \"We can actually take this parsing approach one step further.  We can use the\\nC/C++ parsers to translate source code into C-level declarations in pxd files\\nand then use Cython's own parser to translate from pxd files into pyx files.  This\\nlatter step is the approach taken by the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/uweschmitt/autowrap\"\n  }, \"autowrap\"), \"\\nproject.  A schematic overview of the process is given below\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"960px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"32.08333333333333%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABO0lEQVQY02WRS0sCYRiFv71Q26Bf1KY/EBVR1D5a9wOiC1ktosIIKi+IVNLSNDQdxxClTaVZm8wxwtTKcb75npgpCO2FszoXeM8RuKd+AR/tNtVqlVqthtnt0ssr6oaBYRiupvneoN8vsnXFzj3slyFYgS/Lpmt26FrSFSReYLcEvjJEnhSmJZFSYtuStmkRePzxOhm5V4UYT4LwfiK22gwEIFG441pLcxQIETsLM5oAsdZCbLYYDioutDx6VuPAt0copjEYALHRQHg7TKdAjDmBq03E+hseP1wWS+S0NCfRcwpXcUZiIJbqiBWDIb8krhfRtQynkTDRzA2eQxDLz27GlBN4/KCYSMJsBhZ0hUXvbd8qJlMwk4bFfC9nAvO6Yk4D59NgRSH6S0XZbkcOLCn/jaLsP97R9o/yDQPVoy0ocgcyAAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"cython_parse\",\n    \"title\": \"cython_parse\",\n    \"src\": \"/static/24a49c93ee46e946935dbe7a92204a90/7d769/cython_parse.png\",\n    \"srcSet\": [\"/static/24a49c93ee46e946935dbe7a92204a90/5243c/cython_parse.png 240w\", \"/static/24a49c93ee46e946935dbe7a92204a90/ab158/cython_parse.png 480w\", \"/static/24a49c93ee46e946935dbe7a92204a90/7d769/cython_parse.png 960w\", \"/static/24a49c93ee46e946935dbe7a92204a90/0a200/cython_parse.png 1434w\"],\n    \"sizes\": \"(max-width: 960px) 100vw, 960px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  }), \"\\n    \")), mdx(\"h2\", null, \"Pycparser\"), mdx(\"p\", null, \"Pycparser is a C parser written in pure python. We can use it to parse C header\\nfiles and generate corresponding pxd files.  For the purpose of this post, we'll\\nuse an example C file from the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/fragglet/c-algorithms\"\n  }, \"c-algorithms library\"), \"\\nIn particular, we'll focus on its implementation of a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Trie\"\n  }, \"trie\"), \"\\ndata structure (trie.h), annotated in the snippet below:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"// trie.h\\n\\ntypedef struct _Trie Trie;\\n\\ntypedef void *TrieValue;\\n\\nTrie *trie_new(void);\\n\\nvoid trie_free(Trie *trie);\\n\\nint trie_insert(Trie *trie, char *key, TrieValue value);\\n...\\n\")), mdx(\"p\", null, \"The idea is to use pycparser to translate this to the equivalent cython declarations\\nin a pxd file.  The generated pxd file would look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cython\"\n  }, \"# trie.pxd\\n\\ncdef extern from \\\"c-algorithms/src/trie.h\\\":\\n    ctypedef struct Trie:\\n        pass\\n\\n    ctypedef void *TrieValue\\n\\n    Trie *trie_new()\\n    void trie_free(Trie *trie)\\n\\n    int trie_insert(Trie *trie, char *key, TrieValue value)\\n    ...\\n\\n\")), mdx(\"p\", null, \"So the translation consists of the following:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"placing all statements inside a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"cdef extern\"), \" block\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"typedef\"), \" goes to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ctypedef\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"trailing \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \";\"), \" is removed from each statement\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"typedef struct\"), \" goes to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"pass\"), \" (skipped implementation)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"trie_new(void)\"), \" has \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"void\"), \" removed\")), mdx(\"h2\", null, \"AST\"), mdx(\"p\", null, \"These translation are implemented by walking a intermediate data representation\\nknown as an abstract syntax tree (AST).  Each node in the tree is \\\"visited\\\" by a\\ncorresponding visit function.  The AST for this example looks like the following:\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"960px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"56.25%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIDBAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAC/9oADAMBAAIQAxAAAAHXjuCCDhX/xAAYEAEBAAMAAAAAAAAAAAAAAAACARAREv/aAAgBAQABBQJp7PZotpz/AP/EABURAQEAAAAAAAAAAAAAAAAAABAS/9oACAEDAQE/AZP/xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAgEBPwGn/8QAHBAAAQMFAAAAAAAAAAAAAAAAAAECMRESICFB/9oACAEBAAY/AltaQ6em0ph//8QAGhABAAIDAQAAAAAAAAAAAAAAAQARIDFRYf/aAAgBAQABPyEQKhp7LSkH0gpv8w//2gAMAwEAAgADAAAAELf/AP/EABcRAQEBAQAAAAAAAAAAAAAAAAERACH/2gAIAQMBAT8QUtuCHd//xAAXEQEBAQEAAAAAAAAAAAAAAAABABEh/9oACAECAQE/EAhmT1v/xAAbEAEAAgIDAAAAAAAAAAAAAAABABEgQTFx0f/aAAgBAQABPxAsoFOz5GAqxuUNPUTIvLbw/9k=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"ast\",\n    \"title\": \"ast\",\n    \"src\": \"/static/0df3067dab342d277b7b299f3360e1ae/18e3b/ast.jpg\",\n    \"srcSet\": [\"/static/0df3067dab342d277b7b299f3360e1ae/46946/ast.jpg 240w\", \"/static/0df3067dab342d277b7b299f3360e1ae/55489/ast.jpg 480w\", \"/static/0df3067dab342d277b7b299f3360e1ae/18e3b/ast.jpg 960w\", \"/static/0df3067dab342d277b7b299f3360e1ae/60e21/ast.jpg 1440w\", \"/static/0df3067dab342d277b7b299f3360e1ae/69b48/ast.jpg 1920w\"],\n    \"sizes\": \"(max-width: 960px) 100vw, 960px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  }), \"\\n    \")), mdx(\"p\", null, \"In order to walk the AST, I wrote a Cython generator class.  This is slight modification of\\nthe C generator that comes with the pycparser release.  Take a look at my \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/kevingivens/Blog\"\n  }, \"github\"), \"\\nfor more details. The idea is to provide a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"visit_foo\"), \" method for each node type that\\ngenerates the correct Cython implemenation code. Some highlights from the generator are given below\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def visit_Typedef(self, n):\\n    s = 'c' # prepend 'typedef' with 'c'\\n    if n.storage: s += ' '.join(n.storage) + ' '\\n    # handle typedef struct definition\\n    if type(n.type) == c_ast.TypeDecl and type(n.type.type) == c_ast.Struct:\\n        s += self._handle_typedef_struct(n.type)\\n    else:\\n        s += self._generate_type(n.type)\\n    return s\\n\\ndef visit_ParamList(self, n):\\n    ''' return '' if 'void' is only argument\\n    '''\\n    param_list = ', '.join(self.visit(param) for param in n.params)\\n    if param_list == 'void':\\n        return ''\\n    else:\\n        return param_list\\n\\n\")), mdx(\"p\", null, \"In my next post, I will discuss how to use the Cython parser itself to parse pxd files and generate pyx files.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Summary: We discuss an approach towards automating the writing of Cython bindings Part 1, Overview Cython is a wonderful tool for writing…","timeToRead":3,"banner":null}},"pageContext":{"slug":"/automating-the-binding-process-in-cython","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["2744905544","3090400250","318001574"]}